#' Rank Solutions by Total Cost
#'
#' This function ranks solutions generated by the `path_algo` function based on total cost, 
#' balancing noise reduction and signal preservation. The total cost is calculated as 
#' a weighted sum of noise reduction and signal preservation, with weights determined 
#' by the `alpha` parameter.
#'
#' @param result A list returned by the `path_algo` function, containing lambda values, 
#'        beta values, and other related outputs.
#' @param y A numeric vector representing the input signal.
#' @param alpha A numeric value between 0 and 1, specifying the weight of noise reduction 
#'        in the total cost. Defaults to 0.5.
#'
#' @return A data frame containing:
#' \describe{
#'   \item{lambda}{Lambda values corresponding to each solution.}
#'   \item{noise_reduction}{Computed noise reduction for each solution.}
#'   \item{signal_preservation}{Computed signal preservation for each solution.}
#'   \item{total_cost}{Total cost for each solution, balancing noise reduction and signal preservation.}
#'   \item{rank}{The rank of each solution based on total cost, with 1 being the best.}
#' }
#'
#' @examples
#' # Example usage with dummy data
#' y <- c(1, 2, 3, 4)
#' result <- path_algo(y, lambda_0 = 100, method = "tri")
#' ranked_results <- solutions_cost(result, y, alpha = 0.5)
#' print(ranked_results)
#'
#' @export
solutions_cost <- function(result, y, alpha = 0.5) {
  # Validate alpha
  if (!is.numeric(alpha) || alpha < 0 || alpha > 1) {
    stop("Error: 'alpha' must be a numeric value between 0 and 1.")
  }
  
  # Extract values from the result
  lambda_values <- result$lambda_values
  beta_values <- result$beta_values
  num_solutions <- length(beta_values)
  
  # Initialize vectors to store cost components
  noise_reduction <- numeric(num_solutions)
  signal_preservation <- numeric(num_solutions)
  total_cost <- numeric(num_solutions)
  
  # Compute cost components for each solution
  for (i in seq_along(beta_values)) {
    beta <- beta_values[[i]]
    
    # Noise reduction term: Mean squared error
    noise_reduction[i] <- mean((y - beta)^2)
    
    # Signal preservation term: Mean absolute difference
    signal_preservation[i] <- mean(abs(diff(beta)))
    
    # Total cost: Weighted sum of noise reduction and signal preservation
    total_cost[i] <- alpha * noise_reduction[i] + (1 - alpha) * signal_preservation[i]
  }
  
  # Create a data frame for results
  cost_results <- data.frame(
    lambda = lambda_values,
    noise_reduction = noise_reduction,
    signal_preservation = signal_preservation,
    total_cost = total_cost
  )
  
  # Rank solutions by total cost (ascending order, best solution first)
  cost_results$rank <- rank(cost_results$total_cost, ties.method = "first")
  ranked_results <- cost_results[order(cost_results$total_cost), ]
  
  return(ranked_results)
}
